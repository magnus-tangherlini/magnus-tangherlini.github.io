<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>My Test Page</title>
  <link rel="stylesheet" href="../style.css"> <!-- your stylesheet -->
  <link rel="stylesheet" href="./style_proj3.css">
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
</head>

<body>
    <div class="container">
        <nav class="sidebar">
            <ul>
                <li><a href="#1-1">1.1 The Photos</a></li>
                <li><a href="#1-2">1.2 Recovering the Homography</a></li>
                <li><a href="#1-3">1.3 Warping the Images</a></li>
                <li><a href="#1-4">1.4 Rectification</a></li>
                <li><a href="#1-5">1.5 Panoramic Stitching</a></li>
                <li><a href="#2-1">2.1 Corner Detection and ANMS</a></li>
                <li><a href="#2-2">2.2 Feature Descriptors</a></li>
                <li><a href="#2-3">2.3 Feature Matching</a></li>
                <li><a href="#2-4">2.4 RANSAC</a></li>
                
                <!-- Add more projects as needed -->
            </ul>
        </nav>
        <main class="content">
            <nav class="breadcrumb">
                <a href="../index.html">Home</a> > 
                <span class="current">Project 4</span>
            </nav>

            <section class="header">
                <h1>Panoramic Photos!</h1>
                <div class="header-meta">
                    <p class="authorship">Author: Magnus Tangherlini</p>
                    <p class="date">October 6th 2025</p>
                </div>
            
            </section>
            <div class="project-description">
                <h1>Project Overview</h1>
                <p>In this project I'll be taking a look at homographies and (auto)stitching to create panoramas</p>
            </div>

            <div class = 'project-details'>
                <h1>Part 1: Homographies and Mosaics</h1>
                <h2 id = '1-1'>Example Images</h2>
                <p>Here are examples of pairs of images that have the same center of projection but slight rotations. This documents the change in perspective.</p>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './data/living_room_1_small.png' width = 500>
                        <p>image 1</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './data/living_room_2_small.png' width =500>
                        <p>image 2</p>
                    </div>
                </div>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './data/campanile_1_small.png' width = 500>
                        <p>image 1</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './data/campanile_2_small.png' width = 500>
                        <p>image 2</p>
                    </div>
                </div>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './data/wurster_1_small.png' width = 300>
                        <p>image 1</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './data/wurster_2_small.png' width = 300>
                        <p>image 2</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './data/wurster_3_small.png' width = 300>
                        <p>image 3</p>
                    </div>
                </div>
                <p>For this last set of 3 images, I purposefully wanted to get not just a horizontal perspective change, but a vertical perspective change
                    with respect to image 2.
                </p>
                <p>For consistency in the project, I will almost always be warping everything to image_2.</p>
                
                
                
                <h2 id ='1-2'>Recovering the Homography</h2>
                <p>The main idea behind a homography is that what we're looking at when we look at an image
                    is actually pixels on an x, y, z plane, where the z plane is at a distance of 1 from us. A homography is a matrix that 
                    will tilt, shear, rotate, and translate that plane. We then project those pixels back onto the z=1 plane, through the origin.
                    So after the homography, if a pixel is at a large z, projecting it back onto the z=1 plane, that pixel should "appear" smaller to us, (ie closer to the origin). What we're
                    doing is a change of basis and then a shift back into the normal image axes. This is why we use \(w\) as a "scaling constant". \(x'\) and \(y'\) are in terms of being on the 
                    z=1 plane.
                </p>
                <div>
                    \[ \begin{pmatrix} wx' \\ wy' \\ w \end{pmatrix} = 
                    \begin{pmatrix}
                    a & b & c \\
                    d & e & f \\
                    g & h & i
                    \end{pmatrix} \begin{pmatrix} x \\ y \\ 1 \end{pmatrix}
                    \]
                </div>

                <p>We can rewrite this as a system of equations</p>
                <div>
                    \[
                    wx' = ax + by + c \\
                    wy' = dx + ey + f \\
                    w = gx + hy + i 

                    \]
                </div>
                <p>plugging in w we have:</p>
                <div>
                    \[
                    (gx + hy + i)x' = ax + by + c \\
                    (gx + hy + i)y' = dx + ey + f \\
                    \]
                </div>
                <p>if we're solving for x' and y', i is actually some scaling constant so we can 
                    set that to 1 allowing us to only solve for 8 unkowns. 
                </p>
                <div> 
                    \[
                    x' = ax + by + c - gxx' - hyx'\\
                    y' = dx + ey + f - gxy' - hyy'\\
                    \]
                </div>
                <p>we can now write this in matrix form:</p>
                <div>
                    \[ \begin{pmatrix} x' \\ y' \end{pmatrix} = 
                    \begin{pmatrix}
                    x & y & 1 & 0 & 0 & 0 & -xx' & -yx'\\
                    0 & 0 & 0 & x & y & 1 & -xy' & -yy'
                    \end{pmatrix} \begin{pmatrix} a \\ b \\ c \\ d \\ e \\ f \\ g \\ h \end{pmatrix}
                    \]
                </div>
                <p>The nice thing about this setup is we can use least squares to solve this system of equations. If we select more than four points
                    least squares will actually reduce a good amount of noise!
                </p>
                
                <p>Here are the images I'm using to warp:</p>
                <div class = 'image-row' >
                    <div class = 'image-item'>
                        <img src = './data/living_room_1_small.png' width = 500>
                    </div>
                    <div class = 'image-item'>
                        <img src = './data/living_room_2_small.png' width = 500>
                    </div>
                </div>
                <p>Here are the four correspondences I used:</p>
                <div class = 'image-item'>
                    <img src = './output/correspondences_home.png' width = 1000>
                </div>
                <p>Computing the homography gets us this:</p>
                <div>
                    \[\begin{pmatrix} 1.637 & -0.0651 & -304.4343 \\ 
                    0.2757 & 1.2824 & -82.9434 \\
                    0.001 & -0.003 & 1
                    \end{pmatrix}\]
                    
                </div>
                <h3>Another example</h3>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/campanile_1_small.png' width = 500>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/campanile_2_small.png' width = 500>
                    </div>
                </div>
                <div class = 'image-item'>
                    <img src = './output/campanile_correspondences.png' width = 1000>
                </div>
                <p>Computing the homography using least squares gets us this:</p>
                <div>
                    \[\begin{pmatrix} 1.6416 & -0.1798 & -340.9934 \\ 
                    0.4009 & 1.3391 & -162.7263 \\
                    0.001 & -0.0002 & 1
                    \end{pmatrix}\]
                    
                </div>
                <h2 id = '1-3'>Warping the Images</h2>
                <p>Now that we've solved for the H matrix, we can apply this to every pixel in image 1 (making sure to divide out w at the end). 
                    However, with forward mapping, multiple points may land on the same destination pixel.
                    Instead, we'll do inverse mapping. In inverse mapping, we'll pipe the four corners of our image through our H matrix to 
                    create the canvas. Then for every pixel in our canvas, we'll take the inverse of our H matrix, and send it back into our original image.
                    Then we can interpolate the value of the pixel in our canvas by either using nearest neighbors (assigning the value of the pixel in our canvas to the 
                    value of the pixel closest to it in the original image) or linear interpolation, which is a weighted combination of the four surrounding pixels. 
                    It is important that, when sending values back, we make sure to shift it back to the piped cornersâ€”an image's origin lies at (0,0) but applying our H matrix, the origin may land at 
                    (-10, -25)
                </p>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/living_room_NN.jpg' width = 500>
                        <p>nearest neighbor interpolation</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/living_room_bilinear.jpg' width = 500>
                        <p>bilinear interpolation</p>
                    </div>
                </div>
                <h3>Another example</h3>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/warped_campanile_NN.jpg' width = 500>
                        <p>nearest neighbor interpolation</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/warped_campanile_bilinear.jpg' width = 500>
                        <p>bilinear interpolation</p>
                    </div>
                </div>
                <p>zooming in you can notice that bilinear doesn't have as many weird artifacts. These are especially obvious on the borders of our image.</p>
                <h2 id = '1-4'>Rectification</h2>
                <p>The nice thing about rectification is that for a flat surface, the center of projection actually doesn't matter. Because we're assuming the object is a plane,
                    where we stand in relation to the plane is simply a homography of that plane. This leads us to the ability to rectify flat images.
                </p>
                <div class= 'image-item'>
                    <img src = './output/poster_correspondences.png' width = 750>
                </div>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/poster_NN.jpg' width = '300'>
                        <p>nearest neighbor</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/poster_bilinear.jpg' width = '300'>
                        <p>bilinear interpolation</p>
                    </div>
                    
                </div>
                <p>Here is another example between the tradeoffs of nearest-neighbors and bilinear interpolation.
                    The left image looks like it retains more specifics while the bilinear interpolation looks smudged.
                </p>    
                <h3>Another example</h3>
                <div class ='image-item'>
                    <img src = './output/discussion_correspondences.png' width = '1000'>  
                </div>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/NN_discussion.jpg' width = '500'>
                        <p>nearest neighbors</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/bilinear_discussion.jpg' width = '500'>
                        <p>bilinear</p>
                    </div>
                </div>
                

            
                <h2 id = '1-5'>Panoramic Stitching</h2>
                <p>Lets go back to the original images of the house. Here they are on a canvas that fits them</p>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/canvas_1_living_room.jpg' width = '500'>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/canvas_2_living_room.jpg' width = '500'>
                    </div>
                </div>
                <p>If we simply lay them over eachother, we can get ok results:</p>
                <div class = 'image-item'>
                    <img src = './output/living_room_without_blending.jpg' width = '700'>
                </div>
                <p>The two caveats about this is the order in which we lay them on top of each other matters and it doesn't look very good.
                    Instead, we'll try to create a binary mask and run a laplacian pyramid over it, like in project 3, in order to morph them together. 
                    If we color the distance for our images to the black background, and binarize a mask, we'll wind up with this:  
                </p>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/living_room_dmap1.jpg' width = '300'>
                        <p>Distance Map 1, DMAP_1</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/living_room_dmap2.jpg' width = '300'>
                        <p>Distance Map 2, DMAP_2</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/mask_living_room.jpg' width = '300'>
                        <p>Binarized DMAP_1 > DMAP_2</p>
                    </div>
                </div>
                <p>Running our laplacian stack with 7 layers and merging we get a morphed image. Here is a side-by-side comparison</p>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/living_room_without_blending.jpg' width = '500'>
                        <p>without blending</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/living_room_blended.jpg' width = '500'>
                        <p>with blending</p>
                    </div>
                </div>
                <h3>Another example</h3>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/campanile_mosaic_1.jpg' width = '500'>

                    </div>
                    <div class = 'image-item'>
                        <img src = './output/campanile_mosaic_2.jpg' width = '500'>
                    </div>
                </div>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/unblended_campanile.jpg' width = '500'>
                        <p>without blending</p> 
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/blended_campanile.jpg' width = '500'>
                        <p>with blending</p>
                    </div>
                </div>
                <p>We can also do this with 3 photos, no-matter the rotation!</p>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/part2/wurster_1_hand_mosaic.jpg' width = '500'>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/part2/wurster_2_hand_mosaic.jpg' width = '500'>
                    </div>
                </div>
                <div class ='image-item'>
                    <img src = './output/part2/wurster_1_by_hand.jpg' width = '700'>
                </div>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/part2/wurster_3_mosaic_hand.jpg' width = '500'>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/part2/wurster_4_mosaic_hand.jpg' width = '500'>
                    </div>
                </div>
                <div class ='image-item'>
                    <img src = './output/part2/wurster_total_hand_mosaic.jpg' width = '700'>
                </div>
    
                <h1>Part 2: Automatic Alignment</h1>
                <h2 id = '2-1'>Corner Detection and ANMS</h2>
                <p>The idea behind corner detection is that a corner exists if there are changes in intensity in both the x and y direction. 
                    We'll first calculate the gradients in the x, and y direction. Then we can grab a small patch over a pixel in the gradient images. We can then compute M which is defined as 
                    \[M=\begin{pmatrix}
                    \sum I_x^2 & \sum I_xI_y \\
                    \sum I_xI_y & \sum I_y^2
                    \end{pmatrix}\]
                    Where \(I_x\) and \(I_y\) are the gradient matrices for that patch of pixels and \(I_xI_y\) is just the pairwise products between the two matrices. The Harris corner value at that pixel will be often be 
                    \[Corner= \frac{detM}{traceM}\] 
                    since large values will be associated with large eigenvalues (i.e large changes in both X and Y) and small values will be associated with small eigenvalues.
                </p>
                <div class='image-item'>
                    <img src = './output/part2/wurster_1_gray.jpg'>
                </div>
                <p>This is what the harris corner values reveals about the image</p>
                <div class ='image-item'>
                    <img src = './output/part2/wurster_1_harris_vals.jpg'>
                </div>
                <p>And grabbing the top points:</p>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/part2/wurster_1_500.png' width = '500'>
                        <p>top 500 points</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/part2/wurster_1_250.png' width = '500'>
                        <p>top 250 points</p>
                    </div>
                </div>
                <p>Even though corners are exactly what we're looking for, 
                    simply selecting the top corners is not very robust. From the images 
                    alone you can see that points will cluster towards highly distinct areas, 
                    but if you had another image and it didn't contain that highly distinct area, the number of correspondences 
                    between those two images might be very small. 
                </p>
                <h3>Adaptive Non-Maximal Suppression (ANMS)</h3>
                <p>This is where ANMS comes in. The idea here is that 
                    from each corner, say \( x_i \), we want to look at all the corners that still have a significantly stronger
                    harris corner detection value, point \(x_j\). For each of those \(x_j\)'s that we kept, we will calculate the distance from \(x_i\) to each \(x_j\), find the smallest distance, and assign that distance value to \(r_i\). 
                    We'll then sort and grab the top \(r_i\)'s. We can formulate each \(r_i\) into this equation:
                    $$r_i =\underset{\text{j}}{min} \lVert x_i - x_j \rVert_2 \: \textrm{ s.t.} f(x_i) < c * f(x_j)$$
                    It's important to note that this actually leaves out the maximum corner value since the inequality will always be untrue. However, we can change this 
                    by manually placing it in. This gives us a much more robust version of the top harris corners.
                </p>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/part2/wurster_1_ANMS_500.png' width = 500>
                        <p>500 points, \(c\) = 0.9</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/part2/wurster_1_ANMS_250.png' width = 500>
                        <p>250 points, \(c\) = 0.9</p>
                    </div>
                </div>
                <p>Another way to think about this is that from each point, we only consider "stronger" points. If there's a point that doesn't have a very
                    strong harris corner value but is very far away from any other stronger point, we want to give that point more importance than a point that is close to a very strong point. 
                    Unfortunately, the get_harris_corners function actually may give us points that are associated with extremely small values (ie points in the sky may have a value of 1e-5), allowing for large \(r_i\)'s for "non-existent" corners. In my implementation,
                    I assigned points under a threshold of 1e-4 an \(r_i\) of 0.  
                </p>
                <h2 id = '2-2'>Feature Descriptors</h2>
                <p>Even though that we have edges, we don't have enough information to figure out 
                    how to match them between two images. This is where a feature descriptor comes in. The idea behind a feature descriptor is 
                    that we'll take some small window around the pixel, and attach that to the corner. In order to get robust features, we'll first blur the image,
                    grab a 40x40 patch, and downsample it to 8x8, and normalize it to have mean 0 and variance 1.
                </p>

                <div class = 'image-row'>
                    <div class ='image-item'>
                        <p>patch 1</p>
                        <img src = './output/part2/features/patch_0_big.jpg' width = 150 style="image-rendering: pixelated;">
                        <p>40x40</p>
                    </div>
                    <div class ='image-item'>
                        <p>patch 2</p>
                        <img src = './output/part2/features/patch_1_big.jpg' width = 150 style="image-rendering: pixelated;">
                        <p>40x40</p>
                    </div>
                    <div class ='image-item'>
                        <p>patch 3</p>
                        <img src = './output/part2/features/patch_2_big.jpg' width = 150 style="image-rendering: pixelated;">
                        <p>40x40</p>
                    </div>
                    <div class ='image-item'>
                        <p>patch 4</p>
                        <img src = './output/part2/features/patch_3_big.jpg' width = 150 style="image-rendering: pixelated;">
                        <p>40x40</p>
                    </div>
                    <div class ='image-item'>
                        <p>patch 5</p>
                        <img src = './output/part2/features/patch_4_big.jpg' width = 150 style="image-rendering: pixelated;">
                        <p>40x40</p>
                    </div>
                </div>
                <div class = 'image-row'>
                    <div class ='image-item'>
                        <img src = './output/part2/features/patch_0_small.jpg' width = 150 style="image-rendering: pixelated;">
                        <p>8x8</p>
                    </div>
                    <div class ='image-item'>
                        <img src = './output/part2/features/patch_1_small.jpg' width = 150 style="image-rendering: pixelated;">
                        <p>8x8</p>
                    </div>
                    <div class ='image-item'>
                        <img src = './output/part2/features/patch_2_small.jpg' width = 150 style="image-rendering: pixelated;">
                        <p>8x8</p>
                    </div>
                    <div class ='image-item'>
                        <img src = './output/part2/features/patch_3_small.jpg' width = 150 style="image-rendering: pixelated;">
                        <p>8x8</p>
                    </div>
                    <div class ='image-item'>
                        <img src = './output/part2/features/patch_4_small.jpg' width = 150 style="image-rendering: pixelated;">
                        <p>8x8</p>
                    </div>
                </div>
                
                <h2 id = '2-3'>Feature Matching</h2>
                <p>Now that we have a list of descriptors for each corner, for each image, we'll now attempt to match similiar looking corners up between the images.
                    To do this, we'll run a naive algorithm, calculating the euclidean distance \(e_i\) between every patch in image 1, \(p_i\), to every patch in image 2, \(p_j\). 
                    We'll keep patches (\(p_i, p_j\)) if the next closest match (\(p_i, p_k\)) is significantly larger. In terms of an equation, we can formulate it into:
                    $$ e_1/e_2 < c $$ where \(e_1\) is the error associated with the smallest distance and \(e_2\) is associated with the second smallest distance. 
                    From the paper, it is seen that a cutoff of 0.6 works quite well. However, here is an example of using a larger cutoff. You can see there are correspondences that shouldn't be correspondences.
                    
                </p>
                <div class = 'image-item'>
                    <img src = './output/part2/feature_matching.png' >
                    <p>\(c = 0.6\)</p>
                </div>
                    

                <div class = 'image-item'>
                        <img src = './output/part2/feature_matching_bad.png' >
                        <p>\(c = 0.9\)</p>
                    </div>
                <p>With this in mind, we can find the best matches between the two images!</p>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src= './output/part2/living_room_1.png' width = 500>
                        <p>ANMS corners, top 250</p>
                    </div>
                    <div class = 'image-item'>
                        <img src= './output/part2/living_room_2.png' width = 500>
                        <p>ANMS corners, top 250</p>
                    </div>
                </div>
                <div class = 'image-item'>
                    <img src = './output/part2/living_room_correspondences.png'>
                </div>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src= './output/part2/campanile_1.png' width = 500>
                        <p>ANMS corners, top 250</p>
                    </div>
                    <div class = 'image-item'>
                        <img src= './output/part2/campanile_2.png' width = 500>
                        <p>ANMS corners, top 250</p>
                    </div>
                </div>
                <div class = 'image-item'>
                        <img src= './output/part2/campanile_correspondences.png'>
                </div>
                <p>Its a bit crazy how good the feature mapping is</p>
                <h2 id = '2-4'>RANSAC</h2>
                <p>Now that we have our correspondences, there's a possiblity that we'll have 
                    corresponding corners that shouldn't be correspondences. To avoid this, we'll run an algorithm called RANSAC. The algorithm for RANSAC as is follows
                </p>
                <div>
                    <pre>
                        <code>
                            def RANSAC((im1, im2 correspondences), error, iterations)
                                Repeat iterations times:
                                    1. sample 4 random points from the correspondences 
                                    2. compute the homography, H
                                    3. For every original point in the pre-warped image correspondences, warp them using H (im1')
                                    
                                    
                                    4. calculate the new distance between all warped points (im1') and the correspondence point (im2).
                                    5. Count the number of inliers (the number of points where the distance is less than the error)
                                    and remember those points.
                                

                                6. Get the inliers associated with H that correspond to the most amount of inliers
                                7. Recaculate H using least squares, using the inliers
                              
                        </code>
                    </pre>
                </div>
                <p>after running this code on our initial image, we can find our new warped output and create the mosaic</p>

                    
                <div class = 'image-item'>
                    <img src = './output/part2/blended_wurster_1.jpg' width = 700>
                    auto
                </div>

                <p>and with that here are all the before and after blended images. </p>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/part2/wurster_total_hand_mosaic.jpg' width = 500>
                        <p>by hand</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/part2/large_pano_auto.jpg' width =500>
                        <p>auto</p>
                    </div>
                </div>
                <p>Pay attention to the top left corner and look at the warping going on there. The automatic stitching does 
                    a better job of getting the angle to look correct.
                </p>
                <div class = 'image-row'>
                    <div class = 'image-item'>
                        <img src = './output/living_room_blended.jpg' width = '500'>
                        <p>hand correspondences</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/part2/living_room_auto.jpg' width = '500'>
                        <p>auto</p>
                    </div>
                </div>
                <div class ='image-row'>
                    <div class = 'image-item'>
                        <img src = './output/blended_campanile.jpg' width = '500'>
                        <p>hand correspondences</p>
                    </div>
                    <div class = 'image-item'>
                        <img src = './output/part2/campanile_auto.jpg' width = '500'>
                        <p>hand correspondences</p>
                    </div>
                </div>
                <p>Its also interesting looking at the different sizes in the canvas. The auto stitching seems to do a better 
                    job at retaining scale when warping.
                </p>
            </div>
        </main>

    </div>

</body>


</html>